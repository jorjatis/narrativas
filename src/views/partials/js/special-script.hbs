<script>
document.addEventListener("DOMContentLoaded", () => {
  const mapContainer = document.querySelector(".v-spc-map-c");
  const map = document.querySelector(".v-spc-map");
  const sections = document.querySelectorAll(".v-spc-zone");

  const mapObserver = new IntersectionObserver((entries) => {
    // Filtramos las que están visibles
    const visible = entries.filter(entry => entry.isIntersecting);

    if (visible.length > 0) {
      // Ordenamos por el que está más cerca del top (o el que ocupa más)
      const topMost = visible.reduce((closest, entry) => {
        if (!closest) return entry;
        return entry.boundingClientRect.top < closest.boundingClientRect.top
          ? entry
          : closest;
      }, null);

      if (topMost) {
        const classes = Array.from(topMost.target.classList);
        const zoneClass = classes.find(c => c.startsWith("v-spc-zone--"));

        if (zoneClass) {
          const num = zoneClass.split("--")[1];

          // Resetear clase del mapa (versión más concisa)
          map.classList.forEach(c => c.startsWith("v-spc-map--") && map.classList.remove(c));

          // Añadir nueva clase
          map.classList.add(`v-spc-map--${num}`);
        }
      }
    }
  }, {
    root: null,
    rootMargin: "0px",
    threshold: 0.25
  });

  sections.forEach(zone => mapObserver.observe(zone));

  // Detectar cuando el sticky está "pegado"
  const stickyTop = 90; // coincide con tu CSS
  const mediaQuery = window.matchMedia("(max-width: 1395px)");

  const checkSticky = () => {
    if (mediaQuery.matches) {
      const rect = mapContainer.getBoundingClientRect();
      if (rect.top <= stickyTop) {
        mapContainer.classList.add("fog");
      } else {
        mapContainer.classList.remove("fog");
      }
    } else {
      mapContainer.classList.remove("fog");
    }
  };

  window.addEventListener("scroll", checkSticky);
  window.addEventListener("resize", checkSticky);

  // Ejecutar una vez al cargar
  checkSticky();

  const video = document.querySelector(".voc-article--detail .video");
  if (!video) return;

  let alreadyPlayed = false;

  const videoObserver = new IntersectionObserver(
    (entries, obs) => {
      entries.forEach(entry => {
        if (entry.isIntersecting && entry.intersectionRatio >= 1 && !alreadyPlayed) {
          video.play();
          alreadyPlayed = true;
          obs.unobserve(entry.target);
        }
      });
    },
    { threshold: 1 }
  );

  videoObserver.observe(video);
});
</script>